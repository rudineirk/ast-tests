#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals

from tatsu.buffering import Buffer
from tatsu.parsing import Parser
from tatsu.parsing import tatsumasu
from tatsu.util import re, generic_main  # noqa


KEYWORDS = {}  # type: ignore


class ATOMBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        namechars='',
        **kwargs
    ):
        super(ATOMBuffer, self).__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class ATOMParser(Parser):
    def __init__(
        self,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        left_recursion=True,
        parseinfo=True,
        keywords=None,
        namechars='',
        buffer_class=ATOMBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super(ATOMParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            buffer_class=buffer_class,
            **kwargs
        )

    @tatsumasu()
    def _start_(self):  # noqa

        def block0():
            self._statement_()
        self._positive_closure(block0)
        self._check_eof()

    @tatsumasu()
    def _statement_(self):  # noqa
        self._assignment_()

    @tatsumasu('Assignment')
    def _assignment_(self):  # noqa

        def block0():
            self._WHITESPACE_()
        self._closure(block0)
        self._identifier_()
        self.name_last_node('var')

        def block2():
            self._WHITESPACE_()
        self._closure(block2)
        self._token('=')

        def block3():
            self._WHITESPACE_()
        self._closure(block3)
        self._value_()
        self.name_last_node('value')
        self._END_STMT_()
        self.ast._define(
            ['value', 'var'],
            []
        )

    @tatsumasu()
    def _END_STMT_(self):  # noqa
        with self._choice():
            with self._option():
                self._token(';')
            with self._option():
                self._NEWLINE_()
            self._error('no available options')

    @tatsumasu('Identifier')
    def _identifier_(self):  # noqa
        self._LETTER_()

        def block0():
            self._ALPHANUM_()
        self._closure(block0)

    @tatsumasu()
    def _value_(self):  # noqa
        with self._choice():
            with self._option():
                self._TRUE_()
            with self._option():
                self._FALSE_()
            with self._option():
                self._INT_()
            with self._option():
                self._FLOAT_()
            with self._option():
                self._STRING_()
            self._error('no available options')

    @tatsumasu('BoolTrue')
    def _TRUE_(self):  # noqa
        self._token('true')

    @tatsumasu('BoolFalse')
    def _FALSE_(self):  # noqa
        self._token('false')

    @tatsumasu('Int')
    def _INT_(self):  # noqa
        with self._optional():
            with self._choice():
                with self._option():
                    self._token('+')
                with self._option():
                    self._token('-')
                self._error('no available options')

        def block1():
            self._DIGIT_()
        self._positive_closure(block1)

    @tatsumasu('Float')
    def _FLOAT_(self):  # noqa
        with self._choice():
            with self._option():
                with self._optional():
                    with self._choice():
                        with self._option():
                            self._token('+')
                        with self._option():
                            self._token('-')
                        self._error('no available options')

                def block1():
                    self._DIGIT_()
                self._positive_closure(block1)
                self._token('.')

                def block2():
                    self._DIGIT_()
                self._closure(block2)
            with self._option():
                with self._optional():
                    with self._choice():
                        with self._option():
                            self._token('+')
                        with self._option():
                            self._token('-')
                        self._error('no available options')
                self._token('.')

                def block4():
                    self._DIGIT_()
                self._positive_closure(block4)
            self._error('no available options')

    @tatsumasu('String')
    def _STRING_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('"')

                def block0():
                    with self._choice():
                        with self._option():
                            self._pattern(r'[^\\\r\n\f"]')
                        with self._option():
                            self._token('\\"')
                        self._error('no available options')
                self._closure(block0)
                self._token('"')
            with self._option():
                self._token("'")

                def block2():
                    with self._choice():
                        with self._option():
                            self._pattern(r"[^\\\r\n\f']")
                        with self._option():
                            self._token("\\'")
                        self._error('no available options')
                self._closure(block2)
                self._token("'")
            self._error('no available options')

    @tatsumasu()
    def _ZERO_(self):  # noqa
        self._token('0')

    @tatsumasu()
    def _ONE_(self):  # noqa
        self._token('1')

    @tatsumasu()
    def _NONZERO_DIGIT_(self):  # noqa
        self._pattern(r'[1-9]')

    @tatsumasu()
    def _DIGIT_(self):  # noqa
        self._pattern(r'[0-9]')

    @tatsumasu()
    def _UPPERCASE_LETTER_(self):  # noqa
        self._pattern(r'[A-Z]')

    @tatsumasu()
    def _LOWERCASE_LETTER_(self):  # noqa
        self._pattern(r'[a-z]')

    @tatsumasu()
    def _LETTER_(self):  # noqa
        with self._choice():
            with self._option():
                self._UPPERCASE_LETTER_()
            with self._option():
                self._LOWERCASE_LETTER_()
            self._error('no available options')

    @tatsumasu()
    def _ALPHANUM_(self):  # noqa
        with self._choice():
            with self._option():
                self._DIGIT_()
            with self._option():
                self._LETTER_()
            self._error('no available options')

    @tatsumasu()
    def _WHITESPACE_(self):  # noqa
        self._pattern(r'\s+')

    @tatsumasu()
    def _NEWLINE_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._WHITESPACE_()
                with self._option():
                    with self._group():
                        with self._optional():
                            self._token('\\r')
                        self._pattern(r'[\n\r\f]')
                    with self._optional():
                        self._WHITESPACE_()
                self._error('no available options')


class ATOMSemantics(object):
    def start(self, ast):  # noqa
        return ast

    def statement(self, ast):  # noqa
        return ast

    def assignment(self, ast):  # noqa
        return ast

    def END_STMT(self, ast):  # noqa
        return ast

    def identifier(self, ast):  # noqa
        return ast

    def value(self, ast):  # noqa
        return ast

    def TRUE(self, ast):  # noqa
        return ast

    def FALSE(self, ast):  # noqa
        return ast

    def INT(self, ast):  # noqa
        return ast

    def FLOAT(self, ast):  # noqa
        return ast

    def STRING(self, ast):  # noqa
        return ast

    def ZERO(self, ast):  # noqa
        return ast

    def ONE(self, ast):  # noqa
        return ast

    def NONZERO_DIGIT(self, ast):  # noqa
        return ast

    def DIGIT(self, ast):  # noqa
        return ast

    def UPPERCASE_LETTER(self, ast):  # noqa
        return ast

    def LOWERCASE_LETTER(self, ast):  # noqa
        return ast

    def LETTER(self, ast):  # noqa
        return ast

    def ALPHANUM(self, ast):  # noqa
        return ast

    def WHITESPACE(self, ast):  # noqa
        return ast

    def NEWLINE(self, ast):  # noqa
        return ast


def main(filename, startrule, **kwargs):
    with open(filename) as f:
        text = f.read()
    parser = ATOMParser()
    return parser.parse(text, startrule, filename=filename, **kwargs)


if __name__ == '__main__':
    import json
    from tatsu.util import asjson

    ast = generic_main(main, ATOMParser, name='ATOM')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(asjson(ast), indent=2))
    print()

